# -*- coding: utf-8 -*-
"""lancaster_deploy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bNQzV7iW33-1I-ddSJeU_tkOMXM4Dqad
"""

import os
import cv2
import zipfile
from flask import Flask, request, jsonify, send_file
from flask_cors import CORS
from werkzeug.utils import secure_filename

app = Flask(__name__)
CORS(app)  # CORS í™œì„±í™” (ë‹¤ë¥¸ ë„ë©”ì¸ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡)

UPLOAD_FOLDER = "uploads"
RESULT_FOLDER = "results"
ZIP_FOLDER = "zip_files"

os.makedirs(UPLOAD_FOLDER, exist_ok=True)
os.makedirs(RESULT_FOLDER, exist_ok=True)
os.makedirs(ZIP_FOLDER, exist_ok=True)

@app.route("/upload", methods=["POST"])
def upload_multiple_files():

    if "file" not in request.files:
        return jsonify({"error": "íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤."}), 400

    files = request.files.getlist("file")  # âœ… ì—¬ëŸ¬ ê°œì˜ íŒŒì¼ì„ ê°€ì ¸ì˜´
    if not files:
        return jsonify({"error": "ì—…ë¡œë“œëœ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤."}), 400

    result_files = []  # ì••ì¶•í•  ê²°ê³¼ íŒŒì¼ ë¦¬ìŠ¤íŠ¸
    analysis_results = []

    # âœ… CSV í—¤ë” ì¶”ê°€ (í•œ ë²ˆë§Œ ì‹¤í–‰)
    analysis_results.append("íŒŒì¼ëª…, ë¹¨ê°„ë©´ì , íŒŒë€ë©´ì , êµì°¨ë©´ì , ë¹¨ê°•skew, íŒŒë‘skew, ë¹¨ê°•ê°ë„1, ë¹¨ê°•ê°ë„2, ë¹¨ê°•ê°ë„3, ë¹¨ê°•ê°ë„4, ë¹¨ê°•ê°ë„5, ë¹¨ê°•ê°ë„6, ë¹¨ê°•ê°ë„7, ë¹¨ê°•ê°ë„8, ë¹¨ê°•ê°ë„9, íŒŒë‘ê°ë„1, íŒŒë‘ê°ë„2, íŒŒë‘ê°ë„3, íŒŒë‘ê°ë„4, íŒŒë‘ê°ë„5, íŒŒë‘ê°ë„6, íŒŒë‘ê°ë„7, íŒŒë‘ê°ë„8, íŒŒë‘ê°ë„9")

    for file in files:
        filename = secure_filename(file.filename)
        file_path = os.path.join(UPLOAD_FOLDER, filename)
        file.save(file_path)  # âœ… íŒŒì¼ ì €ì¥

        try:
            result_txt, result_img1, result_img2 = image_process(file_path)  # âœ… íŒŒì¼ ì²˜ë¦¬
            result_img1_path = os.path.join(RESULT_FOLDER, f"processed_1_{filename}")
            result_img2_path = os.path.join(RESULT_FOLDER, f"processed_2_{filename}")
            print("")

            cv2.imwrite(result_img1_path, result_img1)  # âœ… ê²°ê³¼ ì´ë¯¸ì§€ 1 ì €ì¥
            result_img2.savefig(result_img2_path , dpi=300, bbox_inches='tight')
            analysis_results.append(result_txt)  # âœ… í…ìŠ¤íŠ¸ ë°ì´í„° ì €ì¥ (íŒŒì¼ì´ ì•„ë‹ˆë¼ ë¬¸ìì—´ ì¶”ê°€)

            result_files.extend([result_img1_path, result_img2_path])  # âœ… ê²°ê³¼ íŒŒì¼ ë¦¬ìŠ¤íŠ¸ ì¶”ê°€

            # âœ… ì›ë³¸ íŒŒì¼ ì‚­ì œ
            os.remove(file_path)
        except Exception as e:
            return jsonify({"error": str(e)}), 500

    # âœ… ì „ì²´ ë¶„ì„ ê²°ê³¼ë¥¼ í•˜ë‚˜ì˜ TXT íŒŒì¼ë¡œ ì €ì¥
    result_txt_path = os.path.join(RESULT_FOLDER, "final_analysis.txt")
    with open(result_txt_path, "w", encoding="utf-8") as f:
        f.write("\n".join(analysis_results))  # âœ… ë¶„ì„ ê²°ê³¼ ì €ì¥

    result_files.append(result_txt_path)  # âœ… ê²°ê³¼ íŒŒì¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€ (ì´ì œ ì •ìƒì ìœ¼ë¡œ ì¶”ê°€ ê°€ëŠ¥)

    # ğŸ”¹ ZIP íŒŒì¼ë¡œ ì••ì¶•
    zip_filename = "processed_results.zip"
    zip_path = os.path.join(ZIP_FOLDER, zip_filename)

    with zipfile.ZipFile(zip_path, "w") as zipf:
        for file in result_files:
            zipf.write(file, os.path.basename(file))  # âœ… ê²°ê³¼ íŒŒì¼ì„ ZIPì— ì¶”ê°€

    return jsonify({
        "message": f"{len(files)}ê°œì˜ íŒŒì¼ì´ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤!",
        "zip_file": zip_filename
    })

@app.route("/download/<filename>", methods=["GET"])
def download_file(filename):
    zip_path = os.path.join(ZIP_FOLDER, filename)
    if os.path.exists(zip_path):
        return send_file(zip_path, as_attachment=True)
    return jsonify({"error": "íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}), 404


def home():
    return "Flask ì„œë²„ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤!"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)
"""
port = 5000
public_url = ngrok.connect(port).public_url
print(f"ğŸš€ ngrok URL: {public_url}")
app.run(port=port)"""

def image_process(filename):
  from sklearn.cluster import KMeans
  import numpy as np
  from scipy.spatial import ConvexHull
  from shapely.geometry import Polygon
  import matplotlib.pyplot as plt
  from math import atan2
  import os
  import cv2

  ############################################################################
  # 1. ì´ë¯¸ì§€ë¥¼ ë¡œë“œ
  image = cv2.imread(filename)

  image_rgb = image
  img0=image
############################################################################
  # 2. ì´ë¯¸ì§€ì—ì„œ blue, red color ì¶”ì¶œ

  # ì´ë¯¸ì§€ì˜ ê° í”½ì…€ì—ì„œ RGB ê°’ì„ ì¶”ì¶œ
  # RGB ê°’ì„ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ˆê¸°í™”
  rgb_values = []

  # ì´ë¯¸ì§€ì˜ ê° í”½ì…€ì„ ìˆœíšŒí•˜ë©´ì„œ RGB ê°’ì„ ì¶”ì¶œ
  for row in range(image_rgb.shape[0]):
      for col in range(image_rgb.shape[1]):
          rgb_values.append((col, row, image_rgb[row, col]))

  # RGB ê°’ì´ ì„œë¡œ ë‹¤ë¥¸ í”½ì…€ ê°’ë§Œ í•„í„°ë§
  unique_rgb_values = [value for value in rgb_values if len(set(value[2])) > 1]

  # RGB ê°’ì´ ë¹¨ê°„ìƒ‰ ë˜ëŠ” íŒŒë€ìƒ‰ì— ê°€ê¹Œìš´ì§€ë¥¼ íŒë‹¨í•˜ê¸° ìœ„í•œ ì„ê³„ê°’ì„ ì •ì˜
  # ì´ ì„ê³„ê°’ì€ ìƒ‰ìƒì´ íŠ¹ì • ìƒ‰ì— ê°€ê¹ë‹¤ê³  íŒë‹¨í•  ìˆ˜ ìˆëŠ” ìµœì†Œí•œì˜ ì°¨ì´ë¥¼ ì˜ë¯¸
  color_threshold = 60

############################################################################

  # 3. ë¹¨ê°„ìƒ‰ ì ë“¤ê³¼ íŒŒë€ìƒ‰ ì ë“¤ì„ ë¶„ë¥˜
  red_points = []
  blue_points = []

  for value in unique_rgb_values:
      x, y, rgb = value
      b, g, r = rgb
      # R ê°’ì´ Gì™€ B ê°’ë³´ë‹¤ color_threshold ì´ìƒ ë†’ìœ¼ë©´ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ íŒë‹¨
      if r > g + color_threshold and r > b + color_threshold:
          red_points.append((x, y))
      # B ê°’ì´ Rê³¼ G ê°’ë³´ë‹¤ color_threshold ì´ìƒ ë†’ìœ¼ë©´ íŒŒë€ìƒ‰ìœ¼ë¡œ íŒë‹¨
      elif b > r + color_threshold and b > g + color_threshold:
          blue_points.append((x, y))


  # ë¹¨ê°„ìƒ‰ ì ë“¤ì„ 9ê°œì˜ í´ëŸ¬ìŠ¤í„°ë¡œ ë¶„ë¥˜
  red_points_array = np.array(red_points)
  kmeans_red = KMeans(n_clusters=9, random_state=0).fit(red_points_array)
  red_labels = kmeans_red.labels_


  # íŒŒë€ìƒ‰ ì ë“¤ì„ 9ê°œì˜ í´ëŸ¬ìŠ¤í„°ë¡œ ë¶„ë¥˜
  blue_points_array = np.array(blue_points)
  kmeans_blue = KMeans(n_clusters=9, random_state=0).fit(blue_points_array)
  blue_labels = kmeans_blue.labels_

  # í´ëŸ¬ìŠ¤í„°ë§ ê²°ê³¼ë¥¼ ì´ìš©í•´ ê° í´ëŸ¬ìŠ¤í„°ì˜ ì ë“¤ì„ ë¶„ë¥˜
  red_clusters = [[] for _ in range(9)]
  for point, label in zip(red_points, red_labels):
      red_clusters[label].append(point)

  blue_clusters = [[] for _ in range(9)]
  for point, label in zip(blue_points, blue_labels):
      blue_clusters[label].append(point)

  # ê° í´ëŸ¬ìŠ¤í„°ì˜ ì  ê°œìˆ˜ë¥¼ í™•ì¸
  red_cluster_sizes = [len(cluster) for cluster in red_clusters]
  blue_cluster_sizes = [len(cluster) for cluster in blue_clusters]
############################################################################
# 4. ë¹¨ê°„ ì ê³¼ íŒŒë€ ì ì˜ ì¤‘ì‹¬ì  ê³„ì‚°

  # ê° í´ëŸ¬ìŠ¤í„°ì˜ ì¤‘ì‹¬ ì¢Œí‘œë¥¼ ê³„ì‚°
  red_cluster_centers = []
  blue_cluster_centers = []

  # ë¹¨ê°„ìƒ‰ í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ ì¢Œí‘œ ê³„ì‚°
  for cluster in red_clusters:
      x_center = (np.mean([point[0] for point in cluster]))
      y_center = (np.mean([point[1] for point in cluster]))
      x_center = round(x_center,2)
      y_center = round(y_center,2)

      red_cluster_centers.append((x_center, y_center))

  # íŒŒë€ìƒ‰ í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ ì¢Œí‘œ ê³„ì‚°
  for cluster in blue_clusters:
      x_center = (np.mean([point[0] for point in cluster]))
      y_center = (np.mean([point[1] for point in cluster]))
      x_center = round(x_center,2)
      y_center = round(y_center,2)
      blue_cluster_centers.append((x_center, y_center))


  # ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ë¡œë“œí•˜ì—¬ í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì— ì ì„ í‘œì‹œ
  image_with_cluster_centers = image.copy()

  # ë¹¨ê°„ìƒ‰ í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì„ ë³´ë¼ìƒ‰ ì ìœ¼ë¡œ í‘œì‹œ
  for i, center in enumerate(red_cluster_centers):
      cv2.circle(image_with_cluster_centers, (int(center[0]), int(center[1])), 5, (255, 0, 255), -1)
      cv2.putText(image_with_cluster_centers, str(i+1), (int(center[0]), int(center[1])), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 255), 3)

  # íŒŒë€ìƒ‰ í´ëŸ¬ìŠ¤í„° ì¤‘ì‹¬ì„ ì´ˆë¡ìƒ‰ ì ìœ¼ë¡œ í‘œì‹œ
  for i, center in enumerate(blue_cluster_centers):
      cv2.circle(image_with_cluster_centers, (int(center[0]), int(center[1])), 5, (0, 255, 0), -1)
      cv2.putText(image_with_cluster_centers, str(i+1), (int(center[0]), int(center[1])), cv2.FONT_HERSHEY_SIMPLEX, 1, (100, 155, 100), 3)

  #ì²« ë²ˆì§¸ ì´ë¯¸ì§€
  #cv2_imshow(image_with_cluster_centers)
  img1=image_with_cluster_centers
  #image_with_cluster_centers_path = '1. image_with_cluster_centers.png'
  #cv2.imwrite(image_with_cluster_centers_path, image_with_cluster_centers)


############################################################################


#5. íŒŒë€ê³¼ ë¶‰ì€ ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë©´ì  ì‹œê°í™”

  # ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ë¡œë“œí•˜ê³  ë§ˆìŠ¤í¬ë¥¼ ë‹¤ì‹œ ìƒì„±
  image_red=image.copy()
  mask = np.zeros_like(image_red)
  red_hull = ConvexHull(np.array(red_cluster_centers))

  # BGR ìˆœì„œë¡œ ë¹¨ê°„ìƒ‰ ìƒ‰ìƒì„ ì§€ì •í•˜ì—¬ ë§ˆìŠ¤í¬ì— ìƒ‰ì¹ 
  cv2.fillConvexPoly(mask, np.array([red_cluster_centers[i] for i in red_hull.vertices], dtype=np.int32), (0, 0, 255))

  # ì›ë³¸ ì´ë¯¸ì§€ì— ë§ˆìŠ¤í¬ë¥¼ íˆ¬ëª…í•˜ê²Œ ê²¹ì³ì„œ ì¶”ê°€.  alphaê°’ì„ ì¡°ì •í•˜ì—¬ íˆ¬ëª…ë„ë¥¼ ê²°ì •
  alpha=1.0
  red_mask = cv2.addWeighted(mask, alpha, image_red, 0.7, 0, image_red)
  #ë‘ë²ˆì§¸ ì´ë¯¸ì§€ (ë¹¨ê°„ ë§ˆìŠ¤í¬)
  #cv2_imshow(red_mask)
  img2=red_mask


  # ì˜¬ë°”ë¥¸ ìƒ‰ìƒìœ¼ë¡œ íˆ¬ëª…í•˜ê²Œ ìƒ‰ì¹ ëœ ì´ë¯¸ì§€ë¥¼ ì €ì¥
  #image_with_correct_translucent_red_hull_path = '2. image_with_correct_translucent_red_hull.png'
  #cv2.imwrite(image_with_correct_translucent_red_hull_path, image_red)

  #image_with_correct_translucent_red_hull_path



  # ì›ë³¸ ì´ë¯¸ì§€ë¥¼ ë‹¤ì‹œ ë¡œë“œí•˜ê³  ë§ˆìŠ¤í¬ë¥¼ ë‹¤ì‹œ ìƒì„±
  blue_image=image.copy()
  mask2 = np.zeros_like(blue_image)
  blue_hull = ConvexHull(np.array(blue_cluster_centers))

  # BGR ìˆœì„œë¡œ ë¹¨ê°„ìƒ‰ ìƒ‰ìƒì„ ì§€ì •í•˜ì—¬ ë§ˆìŠ¤í¬ì— ìƒ‰ì¹ 
  cv2.fillConvexPoly(mask2, np.array([blue_cluster_centers[i] for i in blue_hull.vertices], dtype=np.int32), (255, 0, 0))

  # ì›ë³¸ ì´ë¯¸ì§€ì— ë§ˆìŠ¤í¬ë¥¼ íˆ¬ëª…í•˜ê²Œ ê²¹ì³ì„œ ì¶”ê°€ alphaê°’ì„ ì¡°ì •
  alpha=1.0
  blue_mask = cv2.addWeighted(mask2, alpha, blue_image, 0.7, 0, blue_image)
  #ì„¸ë²ˆì§¸ ì´ë¯¸ì§€, íŒŒë€ ë§ˆìŠ¤í¬
  #cv2_imshow(blue_mask)
  img3=blue_mask

  from scipy.spatial import ConvexHull
  import numpy as np

  # Convex Hullì„ êµ¬í•˜ê³  ë©´ì ì„ ê³„ì‚°
  red_hull = ConvexHull(np.array(red_cluster_centers))
  blue_hull = ConvexHull(np.array(blue_cluster_centers))

  red_hull_area = red_hull.volume  # ConvexHullì—ì„œëŠ” 2Dì—ì„œì˜ ë©´ì ì´ 'volume' ì†ì„±ì— ì €ì¥ë©ë‹ˆë‹¤.
  blue_hull_area = blue_hull.volume

  #print("ë¶‰ì€ì˜ì—­ ë©´ì  : "+str(round(red_hull_area, 2))+" íŒŒë€ ì˜ì—­ ë©´ì  : "+str(round(blue_hull_area,2)) )
############################################################################
#6. ì°Œê·¸ëŸ¬ì§„ ì •ë„ í™•ì¸ ìœ„í•œ ì •ì‚¬ê°í˜• ì°¾ê¸°

  def distance_and_points(redOrblue):
    # ê±°ë¦¬ì™€ ì¢Œí‘œ ìŒì„ ì €ì¥í•  ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
    distances_with_points = []
    # ëª¨ë“  ê°€ëŠ¥í•œ ì¢Œí‘œ ìŒì— ëŒ€í•´ ê±°ë¦¬ë¥¼ ê³„ì‚°
    for i in range(len(redOrblue)):
        for j in range(i + 1, len(redOrblue)):
            point1 = redOrblue[i]
            point2 = redOrblue[j]
            distance = np.linalg.norm(np.array(point1) - np.array(point2))
            distances_with_points.append((distance, point1, point2))


    # ê±°ë¦¬ì— ë”°ë¼ ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
    distances_with_points.sort(reverse=True, key=lambda x: x[0])

    # ê°€ì¥ ê¸´ ê±°ë¦¬ì™€ ë‘ ë²ˆì§¸ë¡œ ê¸´ ê±°ë¦¬ë¥¼ ë§Œë“œëŠ” ì¢Œí‘œ ìŒ ì¶”ì¶œ
    longest_distance_pair = distances_with_points[0]
    second_longest_distance_pair = distances_with_points[1]

    #print("ê°€ì¥ ê¸´ ê±°ë¦¬ë¥¼ ë§Œë“œëŠ” ì¢Œí‘œ ìŒ:", longest_distance_pair)
    #print("ë‘ ë²ˆì§¸ë¡œ ê¸´ ê±°ë¦¬ë¥¼ ë§Œë“œëŠ” ì¢Œí‘œ ìŒ:", second_longest_distance_pair)

    rtg_wall = (second_longest_distance_pair[0] / (2**0.5) )
    #print("ì‘ì€ ëŒ€ê°ì„ ìœ¼ë¡œ ë§Œë“¤ì–´ì§€ëŠ” ì •ì‚¬ê°í˜•ì˜ í•œ ë³€ ê¸¸ì´ : ", rtg_wall)
    rtg_area = rtg_wall**2
    #print("ì‘ì€ ëŒ€ê°ì„ ìœ¼ë¡œ ë§Œë“¤ì–´ì§€ëŠ” ì •ì‚¬ê°í˜•ì˜ ë„“ì´ : ", rtg_area,"\n\n")
    return (second_longest_distance_pair, rtg_area)



  #print("ë¹¨ê°„ ì ë“¤ : ")
  red_index = distance_and_points(red_cluster_centers)
  red_rtg_area = red_index[1]
  #print("íŒŒë€ ì ë“¤ : ")
  blue_index = distance_and_points(blue_cluster_centers)
  blue_rtg_area = blue_index[1]



  #print("ì°Œê·¸ëŸ¬ì§„ ì •ë„ - ë¹¨ê°„ ë©´ì  - ë¹¨ê°„ì •ì‚¬ê°í˜• :", red_hull_area-red_rtg_area )
  #print("ì°Œê·¸ëŸ¬ì§„ ì •ë„ - íŒŒë€ ë©´ì  - íŒŒë€ì •ì‚¬ê°í˜• :", blue_hull_area-blue_rtg_area )


  #print("ë¹¨ê°„ ëŒ€ê°ì„  ì¢Œí‘œ ë‘ê°œëŠ” : ",red_index[0][1],"and ",red_index[0][2])
  red_diag_point = (red_index[0][1] , red_index[0][2])
  #print("íŒŒë€ ëŒ€ê°ì„  ì¢Œí‘œ ë‘ê°œëŠ” : ",blue_index[0][1],"and ",blue_index[0][2])
  blue_diag_point = (blue_index[0][1] , blue_index[0][2])

  #ëŒ€ê°ì„ ì„ ì´ë£¨ëŠ” ë‘ ì ì„ ì•Œë ¤ì¤¬ì„ ë•Œ ë‚¨ì€ ê¼­ì§€ì ì˜ ì¢Œí‘œë¥¼ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
  def find_square_vertices(point1, point2):
    #print(point1)
    #print(point2)

    x1=point1[0]
    y1=point1[1]

    x2=point2[0]
    y2=point2[1]

    #print("x1ì€",x1, "y1ì€ : ",y1, " x2 : ", x2, "y2 : ",y2)

    if (x1>x2 and y1>y2 ) or (x2>x1 and y2>y1):
      #ìš°ìƒí–¥ ëŒ€ê°ì„ ì¸ ê²½ìš°
      #ì¢Œì¸¡ ìœ„ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸° (ë‚®ì€ xê°’, ë†’ì€ yê°’)
      LtUp_dot = (min(x1, x2) , max(y1,y2))
      #print("ì¢Œì¸¡ ìœ„ ì ì˜ ì¢Œí‘œëŠ” : ", LtUp_dot)
      #ìš°ì¸¡ ìœ„ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸° (ë†’ì€ xê°’, ë†’ì€ yê°’)
      RtUp_dot = (max(x1, x2), max(y1, y2))
      #print("ìš°ì¸¡ ìƒë‹¨ ì ì˜ ì¢Œí‘œëŠ” : ", RtUp_dot)
      #ìš°ì¸¡ í•˜ë‹¨ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸° (ë†’ì€ xê°’, ë‚®ì€ yê°’)
      RtDn_dot = (max(x1, x2), min(y1, y2))
      #print("ìš°ì¸¡ í•˜ë‹¨ ì ì˜ ì¢Œí‘œëŠ” : ", RtDn_dot)
      #ì¢Œì¸¡ í•˜ë‹¨ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸° (ë‚®ì€ xê°’, ë‚®ì€ yê°’)
      LtDn_dot = (min(x1, x2), min(y1,y2))
      #print("ì¢Œì¸¡ í•˜ë‹¨ ì ì˜ ì¢Œí‘œëŠ” : " ,LtDn_dot)

      #ì¢Œìƒë‹¨ - ìš°ìƒë‹¨ - ìš°í•˜ë‹¨ - ì¢Œí•˜ë‹¨ ìˆœì„œë¡œ ë°°ì—´
      #print( LtUp_dot, RtUp_dot, RtDn_dot, LtDn_dot   )
      vertices = (LtUp_dot, RtUp_dot, RtDn_dot, LtDn_dot)
      return vertices

    else:
      #ìš°í•˜í–¥ ëŒ€ê°ì„ ì¸ ê²½ìš°
      #ì¢Œì¸¡ ìœ„ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸°
      LtUp_dot = (min(x1, x2), max(y1,y2))
      #ì¢Œì¸¡ í•˜ë‹¨ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸° (ë‚®ì€ xê°’, ë‚®ì€ yê°’)
      LtDn_dot = (min(x1,x2), min(y1, y2))
      #print("ì¢Œì¸¡ í•˜ë‹¨ ì ì˜ ì¢Œí‘œëŠ” : ", LtDn_dot)
      #ìš°ì¸¡ ìƒë‹¨ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸°
      RtUp_dot = (max(x1,x2), max(y1, y2))
      #print("ìš°ì¸¡ ìƒë‹¨ ì ì˜ ì¢Œí‘œëŠ” : ", RtUp_dot)
      #ìš°ì¸¡ í•˜ë‹¨ ì ì˜ ì¢Œí‘œ êµ¬í•˜ê¸°
      RtDn_dot = (max(x1,x2)), min(y1,y2)

        #ì¢Œìƒë‹¨ - ìš°ìƒë‹¨ - ìš°í•˜ë‹¨ - ì¢Œí•˜ë‹¨ ìˆœì„œë¡œ ë°°ì—´

      #print(LtUp_dot, RtUp_dot, RtDn_dot, LtDn_dot )
      vertices = (LtUp_dot, RtUp_dot, RtDn_dot, LtDn_dot)
      return vertices

  find_square_vertices( red_diag_point[0], red_diag_point[1]  )

  vertices=find_square_vertices( red_diag_point[0], red_diag_point[1]  )
  square_coords = np.array(vertices, dtype=np.int32)
  square_coords = square_coords.reshape((-1, 1, 2))  # cv2.polylines í•¨ìˆ˜ì— ë§ê²Œ ì¢Œí‘œ í˜•íƒœë¥¼ ë³€í™˜

  mask = np.zeros_like(image_red)
########################################################################################################
  # 7. ì‚¬ê°í˜• ê·¸ë¦¬ê¸° ë° ìƒ‰ì¹ í•˜ê¸° _ red
  # image_redëŠ” ì´ë¯¸ ìƒì„±ëœ cv2 ì´ë¯¸ì§€ ê°ì²´
  # cv2.fillPoly í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ê°í˜• ë‚´ë¶€ë¥¼ ë…¸ë€ìƒ‰ìœ¼ë¡œ ì±„ì›€ (ë…¸ë€ìƒ‰: (0, 255, 255) in BGR)
  cv2.fillPoly(mask, [square_coords], (0, 255, 255))

  # ì›ë³¸ ì´ë¯¸ì§€ì™€ ë§ˆìŠ¤í¬ ë¸”ë Œë”©
  alpha = 0.7  # íˆ¬ëª…ë„ ì„¤ì •
  image_blend = cv2.addWeighted(image_red, 0.8, mask, alpha, 0)
# 4ë²ˆì§¸ ì´ë¯¸ì§€ : skewness_red
  #cv2_imshow(image_blend)
  img4=image_blend


  vertices=find_square_vertices( blue_diag_point[0], blue_diag_point[1]  )
  square_coords = np.array(vertices, dtype=np.int32)
  square_coords = square_coords.reshape((-1, 1, 2))  # cv2.polylines í•¨ìˆ˜ì— ë§ê²Œ ì¢Œí‘œ í˜•íƒœë¥¼ ë³€í™˜

  mask2 = np.zeros_like(blue_image)

  # ì‚¬ê°í˜• ê·¸ë¦¬ê¸° ë° ìƒ‰ì¹ í•˜ê¸° _ blue
  # image_redëŠ” ì´ë¯¸ ìƒì„±ëœ cv2 ì´ë¯¸ì§€ ê°ì²´
  # cv2.fillPoly í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ê°í˜• ë‚´ë¶€ë¥¼ ë…¸ë€ìƒ‰ìœ¼ë¡œ ì±„ì›€ (ë…¸ë€ìƒ‰: (0, 255, 255) in BGR)
  cv2.fillPoly(mask2, [square_coords], (0, 255, 255))

  # ì›ë³¸ ì´ë¯¸ì§€ì™€ ë§ˆìŠ¤í¬ ë¸”ë Œë”©
  alpha = 0.4  # íˆ¬ëª…ë„ ì„¤ì •
  image_blend2 = cv2.addWeighted(blue_image, 1-alpha, mask2, alpha, 0)
#5ë²ˆì§¸ ì´ë¯¸ì§€ : skewness_blue
  #cv2_imshow(image_blend2)
  img5=image_blend2

###################################################################################3
#8. octagon í•¨ìˆ˜ ì´ìš© ìœ„í•œ ì „ì²˜ì¹˜ ë° octagon í•¨ìˆ˜ ì´ìš©


  #yì¢Œí‘œ ë³´ì • (ì´ë¯¸ì§€ íŒŒì¼ì€ yì¢Œí‘œê°€ ìœ„ì—ì„œ ë¶€í„° 0, ì¼ë°˜ ì¢Œí‘œê³„ëŠ” yì¢Œí‘œê°€ ì•„ë˜ì—ì„œë¶€í„° 0)
  #ë³¸ë˜ ì´ë¯¸ì§€ì—ì„œ yì¶• ìµœëŒ€ê¸¸ì´ í™•ì¸
  y_axis_max = image.shape[1]
  #ìƒˆë¡œìš´ ë³€ìˆ˜ì— ì €ì¥ (ê° í´ëŸ¬ìŠ¤í„°ë³„ ì¤‘ì‹¬ì¢Œí‘œ )
  new_red = [(x, y_axis_max - y) for x, y in red_cluster_centers]
  new_blue = [(x, y_axis_max - y) for x, y in blue_cluster_centers]

  def delete_center(centers):
    points = np.array(centers)
    #print(points)

    # ê° ì ì˜ x, y ì¢Œí‘œì˜ í‰ê· ì„ ê³„ì‚°
    x_mean = np.mean(points[:, 0])
    y_mean = np.mean(points[:, 1])

    distance = []

    for point in points:
      distance.append( (point[0]-x_mean)**2 + (point[1]-y_mean)**2 )

    #print(distance)
    min_index = np.argmin(distance)
    #print("ê°€ì¥ ì‘ì€ ì¸ë±ìŠ¤ëŠ” : ", min_index)

    return min_index

  red_center_index = delete_center(new_red)
  del new_red[red_center_index]
  #print("ì¤‘ì•™ì ì´ ì œê±°ëœ ë¹¨ê°„ì  ì¢Œí‘œ : ",new_red)

  blue_center_index = delete_center(new_blue)
  del new_blue[blue_center_index]
  #print("ì¤‘ì•™ì ì´ ì œê±°ëœ íŒŒë€ì  ì¢Œí‘œ : ",new_blue)

  def vertices_order(cluster):
    # ì£¼ì–´ì§„ 8ê°í˜• ê¼­ì§“ì  ì¢Œí‘œë“¤
    octagon_vertices = cluster

    # ê¼­ì§“ì ë“¤ì˜ ì¤‘ì‹¬ì (centroid) ê³„ì‚°
    centroid = np.mean(octagon_vertices, axis=0)

    # ê° ê¼­ì§“ì ê³¼ ì¤‘ì‹¬ì  ì‚¬ì´ì˜ ê°ë„ ê³„ì‚°
    def angle_from_centroid(vertex, centroid):
        return atan2(vertex[1] - centroid[1], vertex[0] - centroid[0])

    # ì¤‘ì‹¬ì ìœ¼ë¡œë¶€í„°ì˜ ê°ë„ì— ë”°ë¼ ê¼­ì§“ì ë“¤ ì •ë ¬
    sorted_vertices = sorted(octagon_vertices, key=lambda vertex: angle_from_centroid(vertex, centroid))

    # ìˆœì„œëŒ€ë¡œ ë°°ì¹˜ëœ ê¼­ì§“ì  ì¢Œí‘œ ì¶œë ¥
    #print("Sorted vertices:", sorted_vertices)
    return sorted_vertices

  red_sorted=vertices_order(new_red)
  blue_sorted=vertices_order(new_blue)

  # red_cluster_centersì™€ blue_cluster_centers ë³€ìˆ˜ì— ì €ì¥ëœ ì¢Œí‘œê°’ìœ¼ë¡œ ë‘ ë‹¤ê°í˜• ìƒì„±
  red_polygon = Polygon(red_sorted)
  blue_polygon = Polygon(blue_sorted)

  # ë‘ ë‹¤ê°í˜•ì˜ êµì°¨ ë¶€ë¶„ ê³„ì‚°
  intersection_polygon = red_polygon.intersection(blue_polygon)

  # êµì°¨í•˜ëŠ” ë‹¤ê°í˜•ì˜ ë©´ì  ê³„ì‚°
  intersection_area = intersection_polygon.area

  #print("êµì°¨í•˜ëŠ” ë¶€ë¶„ì˜ ë©´ì :", intersection_area)

  # matplotlibì„ ì‚¬ìš©í•˜ì—¬ ë‘ ê°œì˜ 8ê°í˜• ë„í˜• ê·¸ë¦¬ê¸°
  fig, ax = plt.subplots()

  octagon1=red_polygon
  octagon2=blue_polygon

  # ì²« ë²ˆì§¸ 8ê°í˜• ë„í˜•: íˆ¬ëª…í•œ ë¹¨ê°„ìƒ‰ìœ¼ë¡œ ìƒ‰ì¹ 
  x1, y1 = octagon1.exterior.xy
  ax.fill(x1, y1, alpha=0.5, fc='red', ec='none')

  # ë‘ ë²ˆì§¸ 8ê°í˜• ë„í˜•: íˆ¬ëª…í•œ íŒŒë€ìƒ‰ìœ¼ë¡œ ìƒ‰ì¹ 
  x2, y2 = octagon2.exterior.xy
  ax.fill(x2, y2, alpha=0.5, fc='blue', ec='none')

#6ë²ˆì§¸ ì´ë¯¸ì§€ : ê²¹ì¹˜ëŠ” ì˜¥íƒ€ê³¤

  # ê·¸ë˜í”„ ì„¤ì •
  ax.set_title('Two Octagons')
  plt.xlabel('X Coordinate')
  plt.ylabel('Y Coordinate')
  plt.axis('equal')
  plt.grid(True)
  #plt.savefig(filename+"_overlapping_area.png", dpi=300, bbox_inches='tight')


###################################################################################3
#9. ê°ë„ ê³„ì‚° by PCA

  def point_angle(point):
    points = np.array(point)
    # ë°ì´í„°ì˜ í‰ê·  ê³„ì‚°
    mean = np.mean(points, axis=0)
    # ë°ì´í„° ì¤‘ì‹¬í™”
    centered_points = points - mean
    # ê³µë¶„ì‚° í–‰ë ¬ ê³„ì‚°
    cov_matrix = np.cov(centered_points, rowvar=False)
    # ê³ ìœ ê°’ê³¼ ê³ ìœ ë²¡í„° ê³„ì‚°
    eigenvalues, eigenvectors = np.linalg.eig(cov_matrix)
    # ê°€ì¥ í° ê³ ìœ ê°’ì— í•´ë‹¹í•˜ëŠ” ê³ ìœ ë²¡í„° ì„ íƒ (ì£¼ì„±ë¶„)
    principal_component = eigenvectors[:, np.argmax(eigenvalues)]
    # ì£¼ì„±ë¶„ ë²¡í„°ì™€ xì¶• ì‚¬ì´ì˜ ê°ë„ ê³„ì‚°
    angle_rad = np.arctan2(principal_component[1], principal_component[0])
    angle_deg = round(abs(np.degrees(angle_rad)), 2)
    #print(f"ê¸°ìš¸ì–´ì§„ ê°ë„: {angle_deg:.2f}ë„")
    return angle_deg

  #for i, cluster in enumerate(red_clusters):
    #print("ë¹¨ê°„ ì ì˜ "+str(i+1)+"ë²ˆì§¸ ì„ ì˜ ê¸°ìš¸ì–´ì§„ ê°ë„ : "+str(point_angle(cluster)))

  #for i, cluster in enumerate(blue_clusters):
    #print("íŒŒë€ ì ì˜ "+str(i+1)+"ë²ˆì§¸ ì„ ì˜ ê¸°ìš¸ì–´ì§„ ê°ë„ : "+str(point_angle(cluster)))


###################################################################################3
#10. ìµœì¢… ê²°ë¡ 

  #ì´í”½ì…€ë©´ì 
  total_pixel=image.shape[0]*image.shape[1]
  #print(image.shape[0]*image.shape[1])
  #ì‹¤ì œ ë€ì¹´ìŠ¤í„° ë©´ì  80 * 80

  # ê³„ì‚°ëœí”½ì…€ë©´ì  / ì´ í”½ì…€ë©´ì  = ì‹¤ì œ ë©´ì  / ì‹¤ì œ ì´ ë©´ì 
  #ì‹¤ì œ ë©´ì  = ê³„ì‚°ëœí”½ì…€ë©´ì  * (ì‹¤ì œì´ë©´ì /ì´í”½ì…€ë©´ì )
  gyesu=6400/total_pixel

  ##ìµœì¢… ê²°ë¡ 

  #print("ëª¨ë“  ë‹¨ìœ„ëŠ” cm^2ì…ë‹ˆë‹¤.")
  #print("ë¶‰ì€ì˜ì—­ ë©´ì  : "+str(round(red_hull_area*gyesu, 2)))
  #print("íŒŒë€ ì˜ì—­ ë©´ì  : "+str(round(blue_hull_area*gyesu,2)) )
  #print("êµì°¨í•˜ëŠ” ë¶€ë¶„ì˜ ë©´ì :", round(intersection_area*gyesu,2))

  #print("ë¹¨ê°„ skew :", round( (red_hull_area-red_rtg_area)*gyesu ,2) )
  #print("íŒŒë‘ skew :", round ( (blue_hull_area-blue_rtg_area)*gyesu ,2) )

  row1 = cv2.hconcat([img0, img1, img2])
  row2 = cv2.hconcat([img3, img4, img5])
  combined = cv2.vconcat([row1, row2])
  #cv2_imshow(combined)
  #cv2.imwrite(filename+"_analysis_process.png", combined)

  final_redarea=str(round(red_hull_area*gyesu, 2))
  final_bluearea=str(round(blue_hull_area*gyesu, 2))
  final_intersectarea=str(round(intersection_area*gyesu,2))
  final_skew_red=str(round( (red_hull_area-red_rtg_area)*gyesu,2))
  final_skew_blue=str(round( (blue_hull_area-blue_rtg_area)*gyesu,2))

  #final_result="ëª¨ë“  ë‹¨ìœ„ëŠ” cm^2ì…ë‹ˆë‹¤. ë¹¨ê°„ë©´ì : "+final_redarea+" íŒŒë€ë©´ì : "+final_bluearea+" êµì°¨ë©´ì : "+final_intersectarea+" ë¹¨ê°•skew: "+final_skew_red+" íŒŒë‘skew: "+final_skew_blue
  #print(final_result)

  red_angle_result = []
  blue_angle_result = []

  for i, cluster in enumerate(red_clusters):
    #print("ë¹¨ê°„ ì ì˜ "+str(i+1)+"ë²ˆì§¸ ì„ ì˜ ê¸°ìš¸ì–´ì§„ ê°ë„ : "+str(point_angle(cluster)))
    red_angle_result.append((point_angle(cluster)))
  for i, cluster in enumerate(blue_clusters):
    #print("íŒŒë€ ì ì˜ "+str(i+1)+"ë²ˆì§¸ ì„ ì˜ ê¸°ìš¸ì–´ì§„ ê°ë„ : "+str(point_angle(cluster)))
    blue_angle_result.append((point_angle(cluster)))

  my_list = [1, 2, 3, 4]
  red_angle_result = ", ".join(map(str, red_angle_result))
  blue_angle_result = ", ".join(map(str, blue_angle_result))

  output = (filename+", "+final_redarea+", "+final_bluearea+", "+final_intersectarea+", "+final_skew_red+", "+
            final_skew_blue + ", " + red_angle_result + ", " +blue_angle_result )
  return [output, combined, fig]
